<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>🧊 ChillForce BTC Key Generator</title>
  <style>
    body {
      font-family: monospace;
      background: #111;
      color: #0f0;
      padding: 2rem;
    }
    button {
      font-size: 1.2rem;
      padding: 0.5rem 1rem;
      margin-bottom: 1rem;
      cursor: pointer;
    }
    pre {
      background: #000;
      padding: 1rem;
      border: 1px solid #0f0;
    }
  </style>
</head>
<body>
  <h1>🚀 ChillForce BTC Generator</h1>
  <button onclick="generate()">🔄 Generate</button>
  <pre id="output">Klik tombol untuk generate address...</pre>

  <!-- Load libraries -->
  <script src="https://cdn.jsdelivr.net/npm/elliptic@6.5.4/dist/elliptic.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jssha@3.2.0/dist/sha.min.js"></script>

  <script>
    let EC;
    let shaReady = false;

    // Tunggu semua library siap
    window.addEventListener("load", () => {
      if (typeof elliptic !== 'undefined') {
        EC = elliptic.ec;
      }
      if (typeof jsSHA !== 'undefined') {
        shaReady = true;
      }
    });

    async function generate() {
      if (!EC || !shaReady) {
        alert("⏳ Tunggu library selesai dimuat...");
        return;
      }

      const ec = new EC('secp256k1');
      const key = ec.genKeyPair();
      const privKey = key.getPrivate('hex');
      const pubKey = key.getPublic(true, 'hex');

      const p2pkh = await generateAddress(pubKey);

      document.getElementById('output').textContent = `
🔑 Private Key (hex): ${privKey}
📡 Public Key (compressed): ${pubKey}
📬 Address (P2PKH): ${p2pkh}
`.trim();
    }

    async function generateAddress(pubKeyHex) {
      const bytes = hexToBytes(pubKeyHex);
      const sha256 = await crypto.subtle.digest("SHA-256", bytes);
      const ripemd160 = new jsSHA("RIPEMD-160", "UINT8ARRAY");
      ripemd160.update(new Uint8Array(sha256));
      const h160 = ripemd160.getHash("HEX");

      const versioned = "00" + h160;
      const checksum = await checksum4(versioned);
      const full = versioned + checksum;
      return base58encode(hexToBytes(full));
    }

    async function checksum4(hex) {
      const first = await crypto.subtle.digest("SHA-256", hexToBytes(hex));
      const second = await crypto.subtle.digest("SHA-256", new Uint8Array(first));
      return bytesToHex(new Uint8Array(second)).slice(0, 8);
    }

    function hexToBytes(hex) {
      return Uint8Array.from(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    const base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    function base58encode(buffer) {
      let x = BigInt('0x' + bytesToHex(buffer));
      let result = '';
      while (x > 0) {
        const mod = x % 58n;
        result = base58[Number(mod)] + result;
        x = x / 58n;
      }
      for (let byte of buffer) {
        if (byte === 0x00) result = '1' + result;
        else break;
      }
      return result;
    }
  </script>
</body>
</html>
